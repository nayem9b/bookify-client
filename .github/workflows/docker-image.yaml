name: Docker Image CI

on:
  push:
    branches: ["main"]

jobs:
  # lint:
  #   name: Super-Linter
  #   runs-on: ubuntu-latest
  #   steps:
  #     - uses: actions/checkout@v3
  #       with:
  #         fetch-depth: 1

  #     - name: Lint codebase
  #       uses: github/super-linter@v4
  #       env:
  #         GITHUB_TOKEN: ${{ secrets.GHCR_PAT }}
  #         DEFAULT_BRANCH: main
  #         VALIDATE_ALL_CODEBASE: false
  #         GITHUB_WORKSPACE: ${{ github.workspace }}
  #         VALIDATE_JAVASCRIPT_ES: true
  #         VALIDATE_JAVASCRIPT_STANDARD: false
  #         VALIDATE_TYPESCRIPT_ES: false
  #         VALIDATE_JSON: false
  #         VALIDATE_YAML: false
  #         VALIDATE_MARKDOWN: false

  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0 # Fetch all history for proper tag detection
          token: ${{ secrets.GHCR_PAT }}

      # Set up git for tagging
      - name: Configure Git
        run: |
          git config user.name github-actions[bot]
          git config user.email github-actions[bot]@users.noreply.github.com

      # Determine the next semantic version
      - name: Get next version
        id: version
        run: |
          # Get the latest tag, defaulting to 0.0.0 if none exists or if the tag is not semver
          LATEST_TAG=$(git tag -l --sort=-v:refname | head -n 1)

          # Ensure the tag is semver-like (optionally prefixed with v); otherwise reset to 0.0.0
          if [ -z "$LATEST_TAG" ] || ! [[ "$LATEST_TAG" =~ ^v?[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            LATEST_TAG="0.0.0"
          fi

          # Strip a leading v if present
          CLEAN_TAG=${LATEST_TAG#v}

          # Parse the latest tag and increment the patch version
          MAJOR=$(echo $CLEAN_TAG | cut -d. -f1)
          MINOR=$(echo $CLEAN_TAG | cut -d. -f2)
          PATCH=$(echo $CLEAN_TAG | cut -d. -f3)

          # Increment patch version
          NEW_PATCH=$((PATCH + 1))
          NEW_VERSION="${MAJOR}.${MINOR}.${NEW_PATCH}"

          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION"

      # Update package.json with new version
      - name: Update package.json version
        run: |
          CURRENT_VERSION=$(node -p "require('./package.json').version")
          NEW_VERSION="${{ steps.version.outputs.new_version }}"

          if [ "$CURRENT_VERSION" != "$NEW_VERSION" ]; then
            npm version $NEW_VERSION --no-git-tag-version
            git add package.json package-lock.json
            git commit -m "chore: bump version to $NEW_VERSION [skip ci]"
            git push
            echo "✓ Version updated from $CURRENT_VERSION to $NEW_VERSION"
          else
            echo "✓ Version already at $NEW_VERSION, skipping update"
          fi

      # Build the Docker image with the new version
      - name: Build the Docker image
        run: docker build . --file Dockerfile --tag nayem9b/bookify-client-github-build:${{ steps.version.outputs.new_version }}

      # Login to Docker Hub
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      # Push the versioned image
      - name: Push versioned image
        run: docker push nayem9b/bookify-client-github-build:${{ steps.version.outputs.new_version }}

      # Push the 'latest' tag as well
      - name: Push latest image
        run: |
          docker tag nayem9b/bookify-client-github-build:${{ steps.version.outputs.new_version }} nayem9b/bookify-client-github-build:latest
          docker push nayem9b/bookify-client-github-build:latest

      # Create git tag for the new version
      - name: Create Git tag
        run: |
          git tag ${{ steps.version.outputs.new_version }}
          git push origin ${{ steps.version.outputs.new_version }}
